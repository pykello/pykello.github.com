((3) 0 () 3 ((p+ #"/home/hadi/projects/pykello.github.com-frog/_src/posts/2015-12-15-cstore-fdw-files.md" . unix) (p+ #"/home/hadi/projects/pykello.github.com-frog/_src/posts/2015-12-12-haskell-skyline.md" . unix) (p+ #"/home/hadi/projects/pykello.github.com-frog/_src/posts/2019-03-20-truncate-part-1.md" . unix)) () (h ! (equal) ((p+ #"/home/hadi/projects/pykello.github.com-frog/_src/posts/2015-12-12-haskell-skyline.md" . unix) f post (u . "Haskell Skyline") (? . 1) 1554703366 (p+ #"/home/hadi/projects/pykello.github.com-frog/2015/12/haskell-skyline.html" . unix) (u . "/2015/12/haskell-skyline.html") (u . "2015-12-12T00:00:00") #f (? . 0) (c (u . "programming") c (u . "haskell") c (u . "fp")) (u . "\n<p>Recently I started learning Haskell by studying the <a href=\"https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0\">Intro to FP Programming</a> course on Edx. Since then, I try to model different problems using Haskell.</p>\n\n<p>One of these problems is the Skyline problem, which goes like this:</p>\n\n<blockquote>\n <p>You are given a set of rectangular buildings in a city, and you should return the skyline view of the city. Input is a sequence of tuples <code>(x_{left}, height,\nx_{right})</code>, each describing a building. The output is a sequence of pairs <code>(x, height)</code> meaning that the height of skyline changed to <code>height</code> at the given x coordinate.</p></blockquote>") #t (u . "\n<p>Recently I started learning Haskell by studying the <a href=\"https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0\">Intro to FP Programming</a> course on Edx. Since then, I try to model different problems using Haskell.</p>\n\n<p>One of these problems is the Skyline problem, which goes like this:</p>\n\n<blockquote>\n <p>You are given a set of rectangular buildings in a city, and you should return the skyline view of the city. Input is a sequence of tuples <code>(x_{left}, height,\nx_{right})</code>, each describing a building. The output is a sequence of pairs <code>(x, height)</code> meaning that the height of skyline changed to <code>height</code> at the given x coordinate.</p></blockquote>\n<!-- more-->\n\n<p>For example, for the input:</p>\n\n<pre><code>[(1,11,5), (2,6,7), (3,13,9), (12,7,16), (14,3,25), (19,18,22),\n   (23,13,29), (24,4,28)]</code></pre>\n\n<p>The output should be:</p>\n\n<pre><code>[(1,11),(3,13),(9,0),(12,7),(16,3),(19,18),(22,3),(23,13),(29,0)]</code></pre>\n\n<p>Below diagrams show the input buildings and the expected skyline side by side:</p>\n\n<p> <img src=\"/img/skyline.svg\" alt=\"Skyline\" /></p>\n\n<h2 id=\"solving-the-problem\">Solving the problem</h2>\n\n<p>You can find an extended analysis of this problem at <a href=\"https://briangordon.github.io/2014/08/the-skyline-problem.html\">Brian Gordon&rsquo;s blog</a> , which explains several solutions of $O(n^2)$ and <code>O(n \\log n)</code> complexity to this problem.</p>\n\n<del>Since sorting of integers can easily be reduce to this problem in linear time, this problem isn't solvable faster than `O(n \\log n)` time.</del>\n\n<p> (See comments)</p>\n\n<p>In this post I&rsquo;m not concerned with the time complexity at all, but mostly with the simplicity of the solution.</p>\n\n<p>It&rsquo;s also okay if a solution if contains a false height change, i.e. if we have two consecutive items in the output that contain the same height. After all, we are only concerned with how the skyline will look, and having a false change doesn&rsquo;t change the shape of skyline.</p>\n\n<h3 id=\"solution-1-calculate-height-of-skyline-at-all-endpoints\">Solution 1. Calculate height of skyline at all endpoints</h3>\n\n<p>We&rsquo;re only interested at changes to the height of skyline, and height can only change where a building starts or ends. The height at a point can be calculated by finding the max height of buildings overlapping that point.</p>\n\n<p>This leads us to the following solution:</p>\n\n<div class=\"brush: haskell\">\n <pre><code>skyline bs = sort (foldl add_endpoints [] bs)\n             where\n                add_endpoints xs (x1, h, x2) =\n                  xs ++ [(x1, height x1), (x2, height x2)]\n                height x =\n                  maximum (0 : [h| (x1, h, x2) &lt;- bs, x &gt;= x1 &amp;&amp; x &lt; x2])</code></pre></div>\n\n<p>This solution has time complexity of <code>O(n^2)</code> and produces some false changes, but it is very simple and easy to understand.</p>\n\n<p>(We can easily remove the false changes by passing the result through another function, but this is good enough for our purpose and our goal is to keep things simple).</p>\n\n<h3 id=\"solution-2-iteratively-add-buildings\">Solution 2. Iteratively add buildings</h3>\n\n<p>One might think we can iteratively add buildings and update the shape of skyline. Since a building can be taller or shorter than the previously added buildings, we may need to handle several cases to make this work correctly.</p>\n\n<p>But if we sort the buildings by height before adding them, we can make the update much simpler. If we know the height of skyline is shorter than current building, then all we need to do is to remove the previous points between the boundries of the current building (since they won&rsquo;t be visible anymore), and then add the two points of building.</p>\n\n<p>This leads us to the following solution:</p>\n\n<div class=\"brush: haskell\">\n <pre><code>skyline bs = sort (foldl add_building [] (sortWith (\\(_,h,_)-&gt;h) bs))\n             where\n                height xs y =\n                  (snd . maximum) ((0, 0): [(x, h)| (x, h) &lt;- xs, x &lt;= y])\n                add_building xs (x1, h, x2) =\n                  [(x, h)| (x, h) &lt;- xs, x &lt; x1 || x &gt; x2] ++\n                  [(x1, h), (x2, height xs x2)]</code></pre></div>\n\n<p><strong>Update</strong>. Initial version of this code, which wrongly added <code>(x2, 0)</code> in <code>add_building</code> was incorrect, for the reason described by Chris_Newton in <a href=\"https://news.ycombinator.com/item?id=10723920\">here</a>.</p>\n\n<p>I think this also looks very simple, although not as simple as the previous solution, with the advantage that it won&rsquo;t generate false height changes as much as previous solution.</p>\n\n<p>The time complexity of this solution is <code>O(n^2)</code>, but if we had used some sort of sorted search tree with <code>O(\\log n)</code> operations instead of using lists, this could easily be improved to <code>O(n \\log n)</code>. After all what we do here is one simple iteration with <code>foldl</code>, and then adding each point exactly once, and removing each end point at most once.</p>\n\n<p>Note that <code>height xs y</code> can also be implemented in <code>O(\\log n)</code> if xs is some kind of sorted search tree.</p>\n\n<h3 id=\"solution-3-divide-and-conquer\">Solution 3. Divide and Conquer</h3>\n\n<p>Since this is functional programming and solutions usually tend to be solved using recursion, we could use a solution similar to merge sort. That is, solve the shape of skyline for each half of the buildings, and then merge the shapes.</p>\n\n<p>The solution will look like:</p>\n\n<div class=\"brush: haskell\">\n <pre><code>skyline [] = []\nskyline [(x1, h, x2)] = [(x1, h), (x2, 0)]\nskyline bs = (skyline (take n bs), 0) `merge` (skyline (drop n bs), 0)\n              where n = (length bs) `div` 2\n\nmerge ([], _) (ys, _) = ys\nmerge (xs, _) ([], _) = xs\nmerge ((x, xh):xs, xh_p) ((y, yh):ys, yh_p)\n  | x &lt; y  = (x, max xh   yh_p) : merge (xs, xh)           ((y, yh):ys, yh_p)\n  | x == y = (x, max xh   yh)   : merge (xs, xh)           (ys, yh)\n  | x &gt; y  = (y, max xh_p yh)   : merge ((x, xh):xs, xh_p) (ys, yh)</code></pre></div>\n\n<p>The <code>merge</code> function doesn&rsquo;t seem very simple, so I wouldn&rsquo;t use this solution if I could use a simpler solution.</p>\n\n<p>Similar to merge sort, the time complexity of this solution is <code>O(n \\log n)</code>.</p>\n\n<h3 id=\"conclusion\">Conclusion</h3>\n\n<p>There are other solutions to this problem too, but I think these three solutions are good representative of the solution space. I love problems which can be solved in several totally different ways, and I found it beautiful that some of the solutions are strikingly simple and easy to understand.</p>\n\n<h3 id=\"related-links\">Related Links</h3>\n\n<ul>\n <li><a href=\"https://news.ycombinator.com/item?id=10722094\">Hacker News discussion</a></li>\n <li><a href=\"https://www.reddit.com/r/haskell/comments/3wiqdy/haskell_skyline/\">Reddit discussion</a></li></ul>")) ((p+ #"/home/hadi/projects/pykello.github.com-frog/_src/posts/2019-03-20-truncate-part-1.md" . unix) f post (u . "PostgreSQL Internals: TRUNCATE, Part 1") (? . 2) 1554778425 (p+ #"/home/hadi/projects/pykello.github.com-frog/2019/03/postgresql-internals-truncate-part-1.html" . unix) (u . "/2019/03/postgresql-internals-truncate-part-1.html") (u . "2019-03-20T00:00:00") (? . 0) #f (c (u . "postgres") c (u . "internals")) (u . "\n<p>You can use TRUNCATE in postgres to delete all of the rows in a table. The main advantage of it compared to using DELETE is performance. For example, using DELETE to delete all rows in a table with 1 million rows takes about 2.3 seconds, but truncating the same table would take about 10ms.</p>\n\n<p>But how does postgres implement TRUNCATE that it is so fast?</p>") #t (u . "\n<p>You can use TRUNCATE in postgres to delete all of the rows in a table. The main advantage of it compared to using DELETE is performance. For example, using DELETE to delete all rows in a table with 1 million rows takes about 2.3 seconds, but truncating the same table would take about 10ms.</p>\n\n<p>But how does postgres implement TRUNCATE that it is so fast?</p>\n<!-- more-->\n\n<h2 id=\"what-happens-when-you-delete\">What happens when you DELETE?</h2>\n\n<p>Each transaction in postgres has a unique transaction id. Postgres for each row keeps the identifiers of earliest transaction (xmin) and the latest transaction (xmax) that can see the row. This helps postgres with concurrency control, but what is relevant to our topic is that when you do a DELETE, postgres iterates over all rows in the table and marks their xmax as the identifier of the current transaction. The row is still physically there, but it won’t be visible to future transactions.</p>\n\n<p>Later, in a process called vacuuming, postgres physically deletes the rows from the disk. To learn more about MVCC and vacuuming in postgres, checkout <a href=\"https://www.percona.com/blog/2018/08/06/basic-understanding-bloat-vacuum-postgresql-mvcc/\">this blogpost</a>.</p>\n\n<h2 id=\"where-does-postgres-store-table-data\">Where does postgres store table data?</h2>\n\n<p>You can get the location of the physical file for a relation using <a href=\"https://www.postgresql.org/docs/11/functions-admin.html#FUNCTIONS-ADMIN-DBLOCATION\">pg_relation_filepath(relname)</a>. For example,</p>\n\n<div class=\"brush: sql\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span></span><span class=\"n\">postgres</span><span class=\"o\">=#</span> <span class=\"k\">SELECT</span> <span class=\"n\">pg_relation_filepath</span><span class=\"p\">(</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">);</span>\n <span class=\"n\">pg_relation_filepath</span>\n<span class=\"c1\">----------------------</span>\n <span class=\"n\">base</span><span class=\"o\">/</span><span class=\"mi\">12368</span><span class=\"o\">/</span><span class=\"mi\">16384</span>\n<span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"k\">row</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>In the output above, 12368 is the database oid, which you can also get from the catalog table <a href=\"https://www.postgresql.org/docs/11/catalog-pg-database.html\">pg_database</a>. 16384 is the relation’s file node number. Every postgres table has an entry in the catalog table <a href=\"https://www.postgresql.org/docs/11/catalog-pg-class.html\">pg_class</a>. pg_class has a column named relfilenode, which is the name of the physical file used to store the table data. You can also use pg_relation_filenode(relname) to get this value.</p>\n\n<p>So postgres stores the table data in $PGDATA/base/DATABASE_OID/RELFILENODE.</p>\n\n<p>(There are some more details on the postgres file layout which are not very relevant to our discussion here. See “<a href=\"https://www.postgresql.org/docs/11/storage-file-layout.html\">Database File Layout</a>” for details).</p>\n\n<h2 id=\"what-happens-when-you-truncate\">What happens when you TRUNCATE?</h2>\n\n<p>As we saw, the physical file used for storing table data is determined by its file node number. The way TRUNCATE works is to assign a new file node number to the relation, and schedule the previous physical file for deletion on transaction commit!</p>\n\n<p>As you can see, using DELETE to delete all table data requires a full table scan and setting xmax of all of the rows. But TRUNCATE is as simple as updating a row in pg_class and unlinking a physical file, which is a much faster operation.</p>\n\n<p>This can be verified by checking the result of pg_relation_filenode(relname) before and after doing TRUNCATE:</p>\n\n<div class=\"brush: sql\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span></span><span class=\"n\">postgres</span><span class=\"o\">=#</span> <span class=\"k\">select</span> <span class=\"n\">pg_relation_filenode</span><span class=\"p\">(</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">);</span>\n <span class=\"n\">pg_relation_filenode</span>\n<span class=\"c1\">----------------------</span>\n                <span class=\"mi\">16384</span>\n<span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"k\">row</span><span class=\"p\">)</span>\n\n<span class=\"n\">postgres</span><span class=\"o\">=#</span> <span class=\"k\">TRUNCATE</span> <span class=\"n\">a</span><span class=\"p\">;</span>\n<span class=\"k\">TRUNCATE</span> <span class=\"k\">TABLE</span>\n\n<span class=\"n\">postgres</span><span class=\"o\">=#</span> <span class=\"k\">select</span> <span class=\"n\">pg_relation_filenode</span><span class=\"p\">(</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">);</span>\n <span class=\"n\">pg_relation_filenode</span>\n<span class=\"c1\">----------------------</span>\n                <span class=\"mi\">16387</span>\n<span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"k\">row</span><span class=\"p\">)</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<h2 id=\"in-the-code\">In the Code</h2>\n\n<p>Entry point for TRUNCATE is <a href=\"https://github.com/postgres/postgres/blob/REL_11_STABLE/src/backend/commands/tablecmds.c#L1312\">ExecuteTruncate()</a> in src/backend/commands/tablecmds.c. This function opens each relation to be truncated using an AccessExclusiveLock, does some checks, and then calls <a href=\"https://github.com/postgres/postgres/blob/REL_11_STABLE/src/backend/commands/tablecmds.c#L1417\">ExecuteTruncateGuts()</a>.</p>\n\n<p>We’ll look at what the checks are and why postgres is acquiring an AccessExclusiveLock in future parts. For now, let’s continue with ExecuteTruncateGuts(). The part in ExecuteTruncateGuts() that we are most interested is <a href=\"https://github.com/postgres/postgres/blob/REL_11_STABLE/src/backend/commands/tablecmds.c#L1609\">where it creates the new relation file node</a>:</p>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre>1\n2\n3\n4\n5\n6\n7\n8\n9</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span></span><span class=\"cm\">/*</span>\n<span class=\"cm\"> * Need the full transaction-safe pushups.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * Create a new empty storage file for the relation, and assign it</span>\n<span class=\"cm\"> * as the relfilenode value. The old storage file is scheduled for</span>\n<span class=\"cm\"> * deletion at commit.</span>\n<span class=\"cm\"> */</span>\n<span class=\"n\">RelationSetNewRelfilenode</span><span class=\"p\">(</span><span class=\"n\">rel</span><span class=\"p\">,</span> <span class=\"n\">rel</span><span class=\"o\">-&gt;</span><span class=\"n\">rd_rel</span><span class=\"o\">-&gt;</span><span class=\"n\">relpersistence</span><span class=\"p\">,</span>\n                            <span class=\"n\">RecentXmin</span><span class=\"p\">,</span> <span class=\"n\">minmulti</span><span class=\"p\">);</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p><a href=\"https://github.com/postgres/postgres/blob/REL_11_STABLE/src/backend/utils/cache/relcache.c#L3311\">RelationSetNewRelfilenode()</a> allocates a new relation file node, schedules the relation for deletion at commit, and updates the pg_class row with the new file node (Well, unless it is a mapped relation, but let’s overlook that for now).</p>\n\n<p>The deletion of storage at commit is done by calling <a href=\"https://github.com/postgres/postgres/blob/REL_11_STABLE/src/backend/catalog/storage.c#L139\">RelationDropStorage()</a>. Postgres keeps a linked list of relation file nodes to be deleted at transaction finish (i.e. in a commit or an abort) in the <a href=\"https://github.com/postgres/postgres/blob/REL_11_STABLE/src/backend/catalog/storage.c#L63\">pendingDeletes</a> link list:</p>\n\n<div class=\"brush: c\">\n <table class=\"sourcetable\">\n  <tbody>\n   <tr>\n    <td class=\"linenos\">\n     <div class=\"linenodiv\">\n      <pre> 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10</pre></div></td>\n    <td class=\"code\">\n     <div class=\"source\">\n      <pre><span></span><span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">PendingRelDelete</span>\n<span class=\"p\">{</span>\n\t<span class=\"n\">RelFileNode</span> <span class=\"n\">relnode</span><span class=\"p\">;</span>          <span class=\"cm\">/* relation that may need to be deleted */</span>\n\t<span class=\"n\">BackendId</span> <span class=\"n\">backend</span><span class=\"p\">;</span>            <span class=\"cm\">/* InvalidBackendId if not a temp rel */</span>\n\t<span class=\"kt\">bool</span> <span class=\"n\">atCommit</span><span class=\"p\">;</span>                <span class=\"cm\">/* T=delete at commit; F=delete at abort */</span>\n\t<span class=\"kt\">int</span> <span class=\"n\">nestLevel</span><span class=\"p\">;</span>                <span class=\"cm\">/* xact nesting level of request */</span>\n\t<span class=\"k\">struct</span> <span class=\"n\">PendingRelDelete</span> <span class=\"o\">*</span><span class=\"n\">next</span><span class=\"p\">;</span><span class=\"cm\">/* linked-list link */</span>\n<span class=\"p\">}</span> <span class=\"n\">PendingRelDelete</span><span class=\"p\">;</span>\n\n<span class=\"k\">static</span> <span class=\"n\">PendingRelDelete</span> <span class=\"o\">*</span><span class=\"n\">pendingDeletes</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span> <span class=\"cm\">/* head of linked list */</span>\n</pre></div>\n</td></tr></tbody></table>\n</div>\n\n<p>RelationDropStorage() just adds an entry to this linked list. Later, when transaction is aborted or committed, <a href=\"https://github.com/postgres/postgres/blob/REL_11_STABLE/src/backend/catalog/storage.c#L293\">smgrDoPendingDeletes()</a> is called which goes over pendingDeletes and applies the changes.</p>")) ((p+ #"/home/hadi/projects/pykello.github.com-frog/_src/posts/2015-12-15-cstore-fdw-files.md" . unix) f post (u . "cstore_fdw and 'Files are Hard'") (? . 0) 1554705766 (p+ #"/home/hadi/projects/pykello.github.com-frog/2015/12/cstore-fdw-and-files-are-hard.html" . unix) (u . "/2015/12/cstore-fdw-and-files-are-hard.html") (u . "2015-12-15T00:00:00") (? . 1) (? . 2) (c (u . "postgres")) (u . "\n<p>I recently came accross the \"<a href=\"http://danluu.com/file-consistency/\">Files are hard</a>\" article, and it made me wonder how reliable is cstore_fdw&rsquo;s design and implementation. <a href=\"https://github.com/citusdata/cstore_fdw/\">cstore_fdw</a> is a columnar store for PostgreSQL that I designed and developed in my previous job at Citus Data.</p>\n\n<p>I am writing this post so my decisions for cstore_fdw&rsquo;s design get reviewed by more people, and I get some feedback and improve the design.</p>") #t (u . "\n<p>I recently came accross the \"<a href=\"http://danluu.com/file-consistency/\">Files are hard</a>\" article, and it made me wonder how reliable is cstore_fdw&rsquo;s design and implementation. <a href=\"https://github.com/citusdata/cstore_fdw/\">cstore_fdw</a> is a columnar store for PostgreSQL that I designed and developed in my previous job at Citus Data.</p>\n\n<p>I am writing this post so my decisions for cstore_fdw&rsquo;s design get reviewed by more people, and I get some feedback and improve the design.</p>\n<!-- more-->\n\n<h2 id=\"file-structure\">File Structure</h2>\n\n<p>Structure of cstore_fdw is similar to <a href=\"https://cwiki.apache.org/confluence/display/Hive/LanguageManual+ORC\">Hive&rsquo;s ORC</a>, but with some differences. One of the biggest differences is that cstore_fdw stores metadata in a separate file, while ORC stores it at the end of data file. The reason for this difference? It made avoiding data corruption much easier, as we will see later.</p>\n\n<p>Each cstore_fdw table consists of two files:</p>\n\n<ul>\n <li>Data file</li>\n <li>Metadata file</li></ul>\n\n<h3 id=\"data-file\">Data File</h3>\n\n<p>cstore_fdw divides rows into stripes. Each stripe is 150K rows by default. For each stripe data is stored in column oriented manner.</p>\n\n<p> <img src=\"/img/cstore-layout.svg\" alt=\"cstore-layout\" /></p>\n\n<h3 id=\"metadata-file\">Metadata File</h3>\n\n<p>Metadata file is a small file which contains some version infomration, plus outline of the data file. This includes location and size of each stripe.</p>\n\n<h2 id=\"operations\">Operations</h2>\n\n<p>Currently the only modification operation that cstore_fdw supports is batch insertion, which can be triggered using:</p>\n\n<div class=\"brush: sql\">\n <pre><code>COPY cstore_table FROM '/path/to/file.csv' WITH CSV;</code></pre></div>\n\n<p>or:</p>\n\n<div class=\"brush: sql\">\n <pre><code>INSERT INTO cstore_table FROM SELECT * FROM some_other_table WHERE some_condition</code></pre></div>\n\n<p>Our plans were to first get batch inserts right, as this on its own was very useful to our customers who used it to store archive data. Then add support for single row inserts, deletes, and updates.</p>\n\n<p>What does happen when we do a batch load?</p>\n\n<ul>\n <li>For every 150K rows construct a new stripe and append it to the data file.  While doing this, never touch the metadata file.</li>\n <li>Sync and close the data file.</li>\n <li>Create a temporary metadata file, and write the metadata which represents the  newly inserted data to it.</li>\n <li>Sync and close the temporary metadata file.</li>\n <li>Rename the temporary metadata file to the main metadata file.</li></ul>\n\n<p>If the system crashes during the first four steps, the table is still in a consistent state and we won&rsquo;t have data corruption.</p>\n\n<p>This is because:</p>\n\n<ul>\n <li>We don&rsquo;t change the main metadata file in these steps.</li>\n <li>We don&rsquo;t overwrite or move the old data in the data file.</li></ul>\n\n<p>What about 5th step? The nice thing here is that the <a href=\"http://pubs.opengroup.org/onlinepubs/009695399/functions/rename.html\">specification</a> of the rename system call requires it to be automic. So this step either is done in full (in which case we&rsquo;ll see the new data) or isn&rsquo;t done at all (in which case we&rsquo;ll see the old data, but we won&rsquo;t have data corruption).</p>\n\n<p>And that is the reason for using a separate file for metadata. I needed an atomic operation to rely on, and rename is atomic. Rewriting the whole data in a new file and doing the rename for data file wasn&rsquo;t an option, since it is very expensive. So instead, we rewrite the small metadata file and do the rename for that.</p>\n\n<p>Of course there were some other designs which avoided file corruption, but I found this design very simple compared to other designs.</p>\n\n<p>Reading the <a href=\"https://news.ycombinator.com/item?id=10729132\">discussion in hacker news</a> for &ldquo;Files are hard&rdquo;, I see that I&rsquo;ve missed a step, which is doing a sync on the parent directory to make the rename durable. That is something we should fix, but I&rsquo;m happy that our design seem to avoid most of the issues discussed in &ldquo;Files are hard&rdquo;.</p>\n\n<h2 id=\"links\">Links</h2>\n\n<ul>\n <li><a href=\"https://news.ycombinator.com/item?id=10741385\">Hacker News Discussion</a></li></ul>"))))
    Title: بهینه‌ساز پستگرس
    Date: 2021-06-20T00:00:00
    Tags: پستگرس

در این نوشته به مباحث زیر می‌پردازیم:

۱. روش‌های یافتن سطرها در پستگرس
۲. روش‌های انجام join در پستگرس
۳. چند مثال از join که کند است و چگونه سریع‌تر کنیم.

لینک ویدئو: [youtu.be/SoJp8cznKrE](https://youtu.be/SoJp8cznKrE)

<!-- more -->

برای ساده‌سازی، پردازش موازی پستگرس در مثال خاموش کرده‌ایم.

```
postgres=# set max_parallel_workers to 0;
postgres=# set max_parallel_workers_per_gather to 0;
```

اصل قضیه مباحث بحث شده حتی موقعی که پردازش موازی روشن باشد هم صادق است.

### مروری کوتاه بر معماری پستگرس

فرض کنید پایگاه داده شما دارای دو جدول به نام‌های `users_table` و `orders_table` است و دارای یک ایندکس به نام `user_id_idx`.

   ![Postgres Architecture](/img/postgres-architecture.svg)

برای جزییات اجرای کوئری، به پست 
[پستگرس چگونه کار می‌کند؟ جلسه یک - زندگی یک کوئری](/fa/2021/04/پستگرس-چگونه-کار-می-کند-جلسه-یک-زندگی-یک-کوئری.html)
مراجعه کنید.

جنبه‌هایی از معماری پستگرس در نمودار بالا که در این مقاله برای ما مهم است:

۱. هر کدام از جدول ها و ایندکس‌ها در فایل یا فایل‌هایی در فایل سیستم ذخیره می‌شوند. مثلا در مثال بالا جدول users_table در فایل `base/12662/16455`
ذخیره شده است و ایندکس `user_id_index` در فایل `base/12662/16512` ذخیره شده است.
۲. پستگرس هر فایل را به صفحه‌های ۸ کیلوبایتی تقسیم می‌کند. این صفحه‌ها واحد خواندن از فایل هستند. یعنی حتی اگر پستگرس تنها به ۴ بایت هم نیاز داشته باشد،
تمام صفحه ۸ کیلوبایتی شامل آن ۴ بایت را می‌خواند.
۳. پستگرس برخی از این صفحه‌های ۸ کیلوبایتی را در بخش Shared Buffers کش می‌کند. در تصویر بالا سه صفحه از جدول users_table، دو صفحه از orders_table، و یک صفحه از
ایندکس user_id_index کش شده است. این کش برای این است که پستگرس کمتر به فایل مراجعه کند و در نتیجه دسترسی کمتری به دیسک داشته باشد. دسترسی به دیسک کند است.
اندازه این کش را می‌توان توسط پارامتر shared_buffers تغییر داد، و مقدار پیش‌فرض آن ۱۲۸ مگابایت است.


#### ساختار یک صفحه یک جدول

هر صفحه جدول شامل اطلاعات یک سری سطر است. شکل زیر ساختار یکی از این صفحه‌های ۸ کیلوبایتی را نمایش میدهد:


   ![Postgres Heap Page](/img/pg-page.png)

در شکل بالا این صفحه دارای اطلاعات سه سطر است:

۱. در ابتدای صفحه، سربرگ (Header) صفحه است.
۲. سپس اشاره‌گرها به اطلاعات هر کدام از سطرها.
۳. اطلاعات سطرها به ترتیب عکس از آخر صفحه چیده می‌شوند.

#### شماره‌گذاری سطرها

پستگرس سطرهای یک جدول را با یک جفت عدد شماره‌گذاری می‌کند که عدد اول شماره صفحه و عدد دوم شماره سطر در آن صفحه را مشخص می‌کند.

مثلا `(4, 10)` اشاره می‌کند به سطر دهم در صفحه چهارم جدول.

#### ساختار یک ایندکس btree

در شکل زیر ساختار یک ایندکس btree را می‌بینید.

   ![Postgres BTree Index](/img/btree-index.png)

۱. هر کدام از گره‌هایی که با رنگ تیره مشخص شده‌اند به صورت یک صفحه‌ی هشت کیلوبایتی در دیسک ذخیره می‌شوند.
۲. گره‌های میانی یا به گره‌های میانی پایین‌تر یا به گره‌های برگ اشاره می‌کنند.
۳. گره‌های برگ شامل یک‌سری اشاره‌گر به سطرهای جدول هستند. همانطور که مشاهده می‌کنید، این اشاره‌گر جفت عدد هستند که مفهوم این جفت‌ها در بخش پیش توضیح داده شد.

مثلا فرض کنید می‌خواهیم `x = 368` را در ایندکس بالا بیابیم. ۳۶۸ بین ۳۶۷ و ۷۳۳ قرار دارد، پس اشاره‌گر مربوط به ۳۶۷ را دنبال می‌کنیم و به دومین گره برگ می‌رسیم. در این گره
در این گره ۳۶۸ را پیدا می‌کنیم و می‌فهمیم که این مقدار ۱۸۳ امین سطر در صفحه اول جدول است.

در این مثال تنها یک سطح میانی بود. تعداد سطوح میانی می‌توان بیشتر باشد. برای جزییات بیشتر به
[این مقاله](https://habr.com/en/company/postgrespro/blog/443284/) مراجعه کنید.


### یافتن سطرها

فرض کنید جدولی را به صورت زیر ایجاد کردیم:

```
CREATE TABLE demo2 (x numeric, y int);
```

و تعدادی سطر با مقادیر تصادفی به آن اضافه کردیم:

```
INSERT INTO demo2
         SELECT random() * 10000, i
         FROM generate_series(1, 1000) i;
```

اکنون پستگرس کوئرهایی با شکل `SELECT * FROM demo2 WHERE x = 1234` را چگونه می‌توان پاسخ دهد؟
در این مرحله چون هیچ داده‌ساختاری برای یافتن سریع‌تر داده‌های این جدول نساخته نشده، پستگرس برای این کوئری و هر کوئری دیگری که به داده‌های جدول `demo2` نیاز دارد، همه جدول را پیمایش می‌کند. یعنی تک تک ۱۰ میلیون سطر را.

این قضیه را می‌توانیم با فرمان EXPLAIN بررسی کنیم:

```
postgres=# EXPLAIN SELECT * FROM demo2 WHERE x = 1234;
                        QUERY PLAN
-----------------------------------------------------------
 Seq Scan on demo2  (cost=0.00..179081.71 rows=1 width=15)
   Filter: (x = '1234'::numeric)
(2 rows)
```

عبارت `Seq Scan` در خروجی بالا نشان می‌دهد که کل جدول پیمایش می‌شود.

اکنون یک ایندکس بر روی ستون x ایجاد می‌کنیم:

```
CREATE INDEX idx_x ON demo2(x);
ANALYZE demo2;
```

(با اجرای دستور ANALYZE پستگرس آماری برای جدول جمع‌آوری کند. در بخش‌های بعد توضیح بیشتری در این مورد خواهیم داد)

اکنون اگر کوئری بالا را تکرار کنیم، مشاهده می‌کنیم که پستگرس از ایندکس ساخته شده استفاده می‌کند:

```
postgres=# EXPLAIN SELECT * FROM demo2 WHERE x = 1234;
                             QUERY PLAN
--------------------------------------------------------------------
 Index Scan using idx_x on demo2  (cost=0.43..8.45 rows=1 width=15)
   Index Cond: (x = '1234'::numeric)
(2 rows)
```

#### Index Scan چه می‌کند؟

عمل Index Scan اشاره‌گر سطرها را از ایندکس پیدا می‌کند و سپس آن اشاره‌گرها را دنبال می‌کند و مقدار سطرها را از جدول اصلی می‌خواند.

یک ایندکس تنها مقدار ستون‌هایی که ایندکس بر روی آن‌ها ساخته شده را دارد. مثلا در مثال بالا که `idx_x` بر روی ستون `x` ساخته شده است،
ایندکس تنها مقدار `x` را دارد و مقدار ستون `y` را ندارد.

در کوئری بالا، یعنی ‍`SELECT * FROM demo2 WHERE x = 1234` مقدار همه ستون‌ها درخواست شده است، پس اطلاعات موجود در ایندکس برای پاسخ به این کوئری
کافی نیست. بنابراین پس از یافتن اشاره‌گرها از ایندکس، مقدار خود سطر از خود جدول خوانده میشود.

#### Index Only Scan

اکنون در کوئری بالا یک تغییر کوچک می‌دهیم و به جای مقدار همه ستون‌ها، تنها مقدار ستون `x` را درخواست می‌کنیم:

```
postgres=# EXPLAIN SELECT x FROM demo2 WHERE x = 1234;
                               QUERY PLAN                                
------------------------------------------------------------------------- 
Index Only Scan using idx_x on demo2  (cost=0.43..8.45 rows=1 width=11)
   Index Cond: (x = '1234'::numeric)
(2 rows)
```

دقت کنید که اکنون کوئری از `Index Only Scan` استفاده می‌کند.

چرا؟ چون همه اطلاعات مورد نیاز این کوئری از ایندکس یافته می‌شود و نیازی به مراجعه به خود جدول نیست.

مزیت `Index Only Scan` به `Index Scan` چیست؟

اندازه فایل جدول و فایل ایندکس را با دستورهای زیر به دست می‌آوریم:

```
postgres=# SELECT pg_size_pretty(pg_relation_size('demo2'));
 pg_size_pretty
----------------
 423 MB
(1 row)

postgres=# SELECT pg_size_pretty(pg_relation_size('idx_x'));
 pg_size_pretty
----------------
 301 MB
(1 row)
```

همانطور که می‌بینید در این مثال انداز جدول حدود ۱.۴ برابر اندازه ایندکس است. پس اگر هم به ایندکس و هم به جدول رجوع کنیم، حدود ۲.۴ برابر
داده بیشتری نسبت به حالتی که تنها به ایندکس رجوع کنیم خواهیم خواند. خواندن از دیسک کند است.
بنابراین پستگرس و سیستم عامل هر کدام بخشی از داده‌های فایل را کش می‌کنند تا تعداد دسترسی‌ها به دیسک کمتر شود.
وقتی حجم داده‌ای که می‌خوانیم کمتر باشد، احتمال اینکه داده‌ها در حافظه اصلی کش شده باشند بیشتر است و تعداد دسترسی‌ها به دیسک کمتر می‌شود و
بنابراین کوئری سریع‌تر اجرا می‌شود.


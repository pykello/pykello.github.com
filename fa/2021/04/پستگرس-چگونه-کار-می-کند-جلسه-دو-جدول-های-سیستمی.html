<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <title>پستگرس چگونه کار می‌کند؟ جلسه دو - جدول‌های سیستمی</title>
    <meta name="description" content="در جلسه یک گفتیم که پستگرس پس از parse کردن کوئری، در مرحله آنالیز ارجاعات به جداول، ستون‌ها،  را بررسی می‌کند.  مثلا در کوئری زیر:  `SELECT a, b FROM t WHERE a > 0;` باید ارجاعات زیر بررسی شوند:   آیا جدولی به نام t وجود دارد؟ در صورت وجود، فراداده‌ی مرب...">
    <meta name="author"      content="هادی مشیدی">
    <meta name="keywords"    content="پستگرس">
    <meta name="viewport"    content="width=device-width, initial-scale=1.0">
    <link rel="icon"      href="/fa/favicon.svg">
    <link rel="canonical" href="http://pykello.github.com/fa//fa/2021/04/%D9%BE%D8%B3%D8%AA%DA%AF%D8%B1%D8%B3-%DA%86%DA%AF%D9%88%D9%86%D9%87-%DA%A9%D8%A7%D8%B1-%D9%85%DB%8C-%DA%A9%D9%86%D8%AF-%D8%AC%D9%84%D8%B3%D9%87-%D8%AF%D9%88-%D8%AC%D8%AF%D9%88%D9%84-%D9%87%D8%A7%DB%8C-%D8%B3%DB%8C%D8%B3%D8%AA%D9%85%DB%8C.html">
    <link rel="next" href="/fa/2021/04/%D9%BE%D8%B3%D8%AA%DA%AF%D8%B1%D8%B3-%DA%86%DA%AF%D9%88%D9%86%D9%87-%DA%A9%D8%A7%D8%B1-%D9%85%DB%8C-%DA%A9%D9%86%D8%AF-%D8%AC%D9%84%D8%B3%D9%87-%DB%8C%DA%A9-%D8%B2%D9%86%D8%AF%DA%AF%DB%8C-%DB%8C%DA%A9-%DA%A9%D9%88%D9%8A%D9%94%D8%B1%DB%8C.html">
    <link rel="prev" href="/fa/2021/06/%D8%A8%D9%87%DB%8C%D9%86%D9%87-%D8%B3%D8%A7%D8%B2-%D9%BE%D8%B3%D8%AA%DA%AF%D8%B1%D8%B3-%D8%A8%D8%AE%D8%B4-%DB%8C%DA%A9%D9%85.html">
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="/fa/css/monochrome.css">
    <link rel="stylesheet" type="text/css" href="/fa/css/pygments.css">
    <link rel="stylesheet" type="text/css" href="/fa/css/scribble.css">
    <link rel="stylesheet" type="text/css" href="/fa/css/custom.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <!-- Feeds -->
    <link rel="alternate" type="application/atom+xml"
          href="/fa/feeds/all.atom.xml" title="Atom Feed">
    <link rel="alternate" type="application/rss+xml"
          href="/fa/feeds/all.rss.xml" title="RSS Feed">
    <!-- JS -->
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-xxxxx', 'auto');
      ga('send', 'pageview');
    </script>
  </head>
  <body>

    <!-- Header -->

    <header id="header" class="parent justify-spaceBetween">
      <div class="inner w100 relative">
        <span class="f-left">
          <a href="/fa">
            <h1>
              <span>the</span>lost<span>packet</span>
            </h1>
          </a>
        </span>
      </div>
    </header>

    <div id="container">
        <main>
            <article>
  <header>
    <h1>پستگرس چگونه کار می‌کند؟ جلسه دو - جدول‌های سیستمی</h1>
    <p class='date-and-tags'>
<time datetime="2021-04-18" pubdate="true">2021-04-18</time> :: <span class="tags"><a href="/fa/tags/%D9%BE%D8%B3%D8%AA%DA%AF%D8%B1%D8%B3.html">پستگرس</a></span></p>
    <p class='authors'><span class="authors">هادی مشیدی</span></p>
  </header>

<p>در <a href="/fa/2021/04/پستگرس-چگونه-کار-می-کند-جلسه-یک-زندگی-یک-کوئری.html">جلسه یک</a> گفتیم که پستگرس پس از parse کردن کوئری، در مرحله آنالیز ارجاعات به جداول، ستون‌ها، &hellip; را بررسی می‌کند.</p>

<p>مثلا در کوئری زیر:</p>

<pre><code>SELECT a, b FROM t WHERE a &gt; 0;</code></pre>

<p>باید ارجاعات زیر بررسی شوند:</p>

<ol>
 <li>آیا جدولی به نام t وجود دارد؟ در صورت وجود، فراداده‌ی مربوط به t (مثل مسیر فایل داده) چیست؟</li>
 <li>آیا جدول t ستون‌هایی به نام a و b دارد؟ در صورت وجود، این ستون‌ها چندمین ستون‌ها در این جدول هستند؟</li>
 <li>نوع داده‌های ستون‌های a و b چیست؟</li>
 <li>فرض کنید نوع ستون a عدد صحیح است. آیا عمل <code>a &gt; 0</code> برای اعداد صحیح تعیین شده است؟ اگر بلی، برای انجام این عمل باید از چه تابعی باید استفاده شود؟</li></ol>

<p>در این بخش به این می‌پردازیم که پستگرس چگونه به سوال‌های بالا پاسخ می‌دهد.</p>

<p>لینک ویدئو: <a href="https://youtu.be/hHkubRh-LXw">youtu.be/hHkubRh-LXw</a></p>
<!-- more-->

<h3 id="پیشنیازها">پیش‌نیازها</h3>

<p>برای دنبال کردن این بخش نیازی ندارید <a href="/fa/2021/04/پستگرس-چگونه-کار-می-کند-جلسه-یک-زندگی-یک-کوئری.html">جلسه یک</a> را خوانده باشید.</p>

<p>ولی نیاز دارید که پستگرس را کامپایل و نصب کرده باشید. گام‌های لازم برای این امر را در  <a href="/fa/2020/05/پستگرس-چگونه-کار-می-کند-جلسه-صفر.html">این مقاله</a> آورده‌ام.</p>

<h2 id="فرادادهی-جدول-pgclass">فراداده‌ی جدول: pg_class</h2>

<p>فراداده‌ی مربوط به جدول‌ها در جدول سیستمی pg_class قرار دارد. مثلا برای اینکه فراداده جدول به نام t را ببینیم، می‌توانیم از کوئری زیر استفاده کنیم. بخش‌هایی از خروجی را در زیر می‌بینید:</p>

<pre><code>postgres=# SELECT * FROM pg_class WHERE relname='t';
-[ RECORD 1 ]-------+------
oid                 | 16394
relname             | t
...
relfilenode         | 16394
...
relkind             | r
relnatts            | 2
...</code></pre>

<p>در خروجی بالا:</p>

<ul>
 <li>مقدار relname نام جدول است.</li>
 <li>مقدار oid شماره داخلی جدول است. در آینده خواهیم دید که این شماره در جدول‌های سیستمی دیگر (مثلا جدول مربوط به ستون‌ها) برای اشاره به جدول استفاده می‌شود.</li>
 <li>مقدار relkind نشان می‌دهد که این رکورد در pg_class در واقع مربوط به یک جدول است. جدول سیستمی pg_class می‌تواند شامل فراداده ایندکس، view، &hellip; نیز باشد که برای آن موارد مقدار relkind متفاوت خواهد بود.</li>
 <li>مقدار relnatts تعداد ستون‌های جدول را نشان می‌دهد.</li></ul>

<h4 id="relfilenode">relfilenode</h4>

<p>در خروجی بالا مقدار relfilenode نام فایلی است که در دیسک برای ذخیره اطلاعات جدول t استفاده شده است. مسیر کامل فایل از فرمول زیر به دست می‌آید:</p>

<pre><code>$PGDATA/base/$database_id/$relfilenode</code></pre>

<p>که <code>$PGDATA</code> مسیر دایرکتوری کلاستر پستگرس است. اسم این دایرکتوری را موقع اجرای initdb انتخاب کردید. اگر مسیر این دایرکتوری را فراموش کرده‌اید، از دستور زیر می‌توانید استفاده کنید:</p>

<pre><code>postgres=# show data_directory;
-[ RECORD 1 ]--+----------------
data_directory | /home/hadi/data</code></pre>

<p><code>$database_id</code> شماره داخلی دیتابیس است. اسم دیتابیسی که ما استفاده می‌کنیم postgres است. برای یافتن شماره آن می‌توانید از جدول pg_class استفاده کنید:</p>

<pre><code>postgres=# select oid from pg_database where datname='postgres';
  oid
-------
 12675
(1 row)</code></pre>

<p>پس برای جدول بالا مسیر فایل مربوط به جدول t، خواهد بود: <code>/home/hadi/data/base/12675/16394</code>.</p>

<p>برای آسانی، می‌توانید از دستور زیر نیز برای یافتن مسیر فایل استفاده کنید:</p>

<pre><code>postgres=# SELECT pg_relation_filepath('t');
 pg_relation_filepath
----------------------
 base/12675/16394
(1 row)</code></pre>

<h4 id="آیا-relfilenode-همیشه-با-شماره-جدول-یکسان-است">آیا relfilenode همیشه با شماره جدول یکسان است؟</h4>

<p>در خروجی بالا دیدیم که هم شماره جدول (oid) و هم relfilenode یکسان و برابر با 16394 بودند. مقدار اولیه این دو یکسان است. مقدار شماره جدول هیچ‌گاه تغییر نمی‌کند، ولی برخی دستورات هستند که ممکن است relfilenode را تغییر دهند. مثلا دستور TRUNCATE که تمام سطرهای یک جدول را حذف می‌کند:</p>

<pre><code>postgres=# truncate t;
TRUNCATE TABLE
postgres=# select oid, relfilenode from pg_class where relname='t';
  oid  | relfilenode
-------+-------------
 16394 |       24586
(1 row)</code></pre>

<p>پیاده‌سازی داخلی TRUNCATE ابتدا یک فایل خالی با نام relfilenode جدید ایجاد می‌کند، سپس مقدار relfilenode را در pg_class تغییر می‌دهد، و سپس فایل قدیمی را پاک می‌کند.</p>

<h4 id="منابع-بیشتر">منابع بیشتر</h4>

<ul>
 <li><a href="https://www.postgresql.org/docs/current/catalog-pg-class.html">اطلاعات کامل درباره pg_class</a></li>
 <li><a href="https://github.com/postgres/postgres/blob/091e22b2e673e3e8480abd68fbb827c5d6979615/src/backend/utils/cache/relcache.c#L3576">کد تغییر relfilenode</a></li></ul>

<h2 id="فراداده-ستونها-pgattribute">فراداده ستون‌ها: pg_attribute</h2>

<p>اینکه جدول چه ستون‌هایی دارد و نوع آن ستون‌ها چیست را می‌توانیم با استفاده از جدول سیستمی pg_attribute به دست بیاوریم.</p>

<p>به ازای هر ستون جدول در pg_attribute یک سطر وجود دارد. علاوه بر این هر جدولی یک سری ستون‌های سیستمی مانند cmax, xmax, cmin, xmin, &hellip; دارد که به ازای آن‌ها نیز یک سر در pg_attribute وجود دارد.</p>

<p>به این ستون‌های سیستمی در جلسات آینده خواهیم پرداخت.</p>

<p>برای اینکه تنها اطلاعات مربوط به ستون‌های غیر سیستمی جدول را ببنیم، شرط <code>attnum &gt; 0</code> را به کوئری زیر اضافه می‌کنیم:</p>

<pre><code>postgres=# select * from pg_attribute where attrelid = 16394 and attnum &gt; 0;</code></pre>

<p>در کوئری بالا فرض شده است که شماره جدول t برابر با 16394 است. مقدار آن را در بالا از pg_class به دست آوردیم.</p>

<p>خروجی کوئری بالا خواهد بود:</p>

<pre><code>-[ RECORD 1 ]--+------
attrelid       | 16394
attname        | a
atttypid       | 23
...
attnum         | 1
...
attisdropped   | f
...
-[ RECORD 2 ]--+------
attrelid       | 16394
attname        | b
atttypid       | 23
...
attnum         | 2
...
attisdropped   | f
...</code></pre>

<p>از جمله اطلاعاتی که در خروجی بالا می‌بینیم:</p>

<ol>
 <li>شماره ترتیبی هر ستون (attnum)</li>
 <li>اسم ستون (attname)</li>
 <li>اینکه آیا ستون حذف شده است یا نه (attisdropped)</li></ol>

<h4 id="حذف-کردن-یک-ستون">حذف کردن یک ستون</h4>

<p>مثلا فرض کنید که دو دستور زیر را اجرا کنیم تا یک ستون حذف شود و یک ستون اضافه شود:</p>

<pre><code>ALTER TABLE t DROP COLUMN b;
ALTER TABLE t ADD COLUMN c text;</code></pre>

<p>اطلاعات ستون‌ها به صورت زیر تغییر خواهد کرد:</p>

<pre><code>postgres=# select attname, attnum, attisdropped from pg_attribute where attrelid = 16394 and attnum &gt; 0;
-[ RECORD 1 ]+-----------------------------
attname      | a
attnum       | 1
attisdropped | f
-[ RECORD 2 ]+-----------------------------
attname      | ........pg.dropped.2........
attnum       | 2
attisdropped | t
-[ RECORD 3 ]+-----------------------------
attname      | c
attnum       | 3
attisdropped | f</code></pre>

<p>همانطور که مشاهده می‌کنید فیلد attisdropped ستون دوم به مقدار true تغییر کرد و اسم آن نیز تغییر کرد.</p>

<p>به اینکه چرا این ستون کلا حذف نشد در جلسات آینده خواهیم پرداخت.</p>

<h4 id="منابع-بیشتر">منابع بیشتر</h4>

<ul>
 <li><a href="https://www.postgresql.org/docs/current/catalog-pg-attribute.html">اطلاعات کامل درباره pg_attribute</a></li></ul>

<h2 id="فراداده-نوعها-pgtype">فراداده نوع‌ها: pg_type</h2>

<p>اکنون که با استفاده از pg_attribute شماره نوع ستون‌ها را بدست آوردیم، می‌توانید با استفاده از  جدول سیستمی pg_type به جزییات نوع‌ها نگاه کنیم.</p>

<p>مثلا در مثال قبلی نوع ستون a شماره 23 داشت. برای مشاهده اطلاعات این نوع از کوئری زیر استفاده می‌کنیم:</p>

<pre><code>postgres=# SELECT * FROM pg_type WHERE oid=23;
-[ RECORD 1 ]--+---------
oid            | 23
typname        | int4
...
typlen         | 4
...
typinput       | int4in
typoutput      | int4out
...</code></pre>

<p>که اطلاعاتی مانند اسم نوع (typname)، طول یک مقدار از این نوع (typlen)، تابع تبدیل رشته به این نوع (int4in)، و تابع تبدیل این نوع به رشته (int4out) را به ما میدهد.</p>

<h4 id="منابع-بیشتر">منابع بیشتر</h4>

<ul>
 <li><a href="https://www.postgresql.org/docs/current/catalog-pg-type.html">اطلاعات کامل درباره pg_type</a></li></ul>

<h2 id="فراداده-عملگرها-و-توابع-pgoperator-و-pgproc">فراداده عملگرها و توابع: pg_operator و pg_proc</h2>

<p>برای اینکه بفهمیم مقایسه <code>a &gt; 0</code> در مثالی که در بالا زدیم چگونه باید اجرا کنیم، مراحل زیر را انجام می‌دهیم:</p>

<ol>
 <li>با استفاده از pg_operator عملگری که نمادش <code>&gt;</code> است و دو عدد صحیح را مقایسه می‌کند را پیدا می‌کنیم</li>
 <li>از رکورد pg_operator اسم تابعی که این عمل به دست می‌آوریم.</li>
 <li>در pg_proc تابعی که در مرحله ۲ یافتیم را پیدا می‌کنیم. رکورد مرتبط در pg_proc اطلاعات کافی برای اجرای تابع را دارد.</li></ol>

<p>مثلا نوع عدد صحیح ۴ بایتی در مثال قبلی دارای شماره 23 بود. برای یافتن عمل مقایسه دو عدد صحیح:</p>

<pre><code>postgres=# select * from pg_operator where oprname='&lt;' and oprleft=23 and oprright=23;
-[ RECORD 1 ]+----------------
oid          | 97
oprname      | &lt;
...
oprleft      | 23
oprright     | 23
oprresult    | 16
...
oprcode      | int4lt
...</code></pre>

<p>از خروجی بالا میفهمیم که خروجی این عملگر دارای نوع 16 یا همون بولین است و اسم تابعی که این عملگر را اجرا می‌کند int4lt است.</p>

<p>برای یافتن اطلاعات مربوط به int4lt:</p>

<pre><code>postgres=# select * from pg_proc where proname='int4lt';
-[ RECORD 1 ]---+-------
oid             | 66
proname         | int4lt
...
prolang         | 12
...
proargtypes     | 23 23
...
prosrc          | int4lt
...</code></pre>

<p>در خروجی بالا ذکر شده است که زبان این تابع 12 است. برای یافتن اطلاعات مربوط به زبان 12:</p>

<pre><code>postgres=# select * from pg_language where oid=12;
-[ RECORD 1 ]-+---------
oid           | 12
lanname       | internal
...</code></pre>

<p>از کنار گذاشتن دو خروجی اخیر میفهمیم که int4lt یک تابع داخلی در سورس کد پستگرس است.</p>

<p>این تابع داخلی در <a href="https://github.com/postgres/postgres/blob/c30f54ad732ca5c8762bb68bbe0f51de9137dd72/src/backend/utils/adt/int.c#L393">postgres/src/backend/utils/adt/int.c</a> میتوانید بیابید.</p>

<h4 id="منابع-بیشتر">منابع بیشتر</h4>

<ul>
 <li><a href="https://www.postgresql.org/docs/current/catalog-pg-operator.html">اطلاعات کامل درباره pg_operator</a></li>
 <li><a href="https://www.postgresql.org/docs/current/catalog-pg-proc.html">اطلاعات کامل درباره pg_proc</a></li></ul>

<h2 id="مثال">مثال</h2>

<p>با چیزهایی که در این جلسه یادگرفتیم، می‌خواهیم یک تابع بنویسیم که اسم جدول را به صورت یک رشته متنی بگیرد و دستور CREATE TABLE آن را به صورت رشته متنی خروجی دهد.</p>

<p>در ویدئو به طور کامل این را توضیح دادیم. نتیجه نهایی عبارت بود از:</p>

<div class="brush: sql">
 <table class="sourcetable">
  <tbody>
   <tr>
    <td class="linenos">
     <div class="linenodiv">
      <pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td>
    <td class="code">
     <div class="source">
      <pre><span></span><span class="k">CREATE</span> <span class="k">FUNCTION</span> <span class="n">table_name_to_create_table</span><span class="p">(</span><span class="k">table_name</span> <span class="nb">text</span><span class="p">)</span> <span class="k">RETURNS</span> <span class="nb">text</span>
<span class="k">AS</span> <span class="err">$$</span>
  <span class="k">SELECT</span> <span class="s1">&#39;CREATE TABLE &#39;</span> <span class="o">||</span> <span class="n">relname</span> <span class="o">||</span> <span class="s1">&#39;(&#39;</span> <span class="o">||</span>
         <span class="n">string_agg</span><span class="p">(</span><span class="n">attname</span> <span class="o">||</span> <span class="s1">&#39; &#39;</span> <span class="o">||</span> <span class="n">typname</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;)&#39;</span>
  <span class="k">FROM</span> <span class="n">pg_type</span><span class="p">,</span> <span class="n">pg_class</span><span class="p">,</span> <span class="n">pg_attribute</span>
  <span class="k">WHERE</span> <span class="n">relname</span><span class="o">=</span><span class="k">table_name</span> <span class="k">and</span>
        <span class="n">pg_class</span><span class="p">.</span><span class="n">oid</span><span class="o">=</span><span class="n">pg_attribute</span><span class="p">.</span><span class="n">attrelid</span> <span class="k">and</span>
        <span class="n">attnum</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">and</span> <span class="k">not</span> <span class="n">attisdropped</span> <span class="k">and</span>
        <span class="n">pg_type</span><span class="p">.</span><span class="n">oid</span><span class="o">=</span><span class="n">atttypid</span>
  <span class="k">group</span> <span class="k">by</span> <span class="n">relname</span><span class="p">;</span>
<span class="err">$$</span> <span class="k">LANGUAGE</span> <span class="k">sql</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table>
</div>

<p>برای جزئیات به ویدئو مراجعه کنید.</p>

<h2 id="تکلیف-کار-در-خانه-">تکلیف کار در خانه 😉</h2>

<p>ثال را تغییر دهید تا با استفاده از فیلد attnotnull جدول pg_attribute برای هر ستون NOT NULL یا NULL درست را اضافه کند.</p>

<p>مثلا اگر جدول به صورت زیر ایجاد شده باشد،</p>

<pre><code>CREATE TABLE t(a int NOT NULL, b int);</code></pre>

<p>خروجی تابعی که در بخش مثال نوشتیم مشخصه NOT NULL ستون اول را ذکر نخواهد کرد. تغییری دهید تا این مشکل برطرف شود.</p>

<p>اگر مشکلی در دنبال کردن این مقاله یا ویدئو داشتید، اگر پیشنهاد یا انتقادی داشتید، یا اگر سوالی داشتید، میتوانید از روش‌های زیر با من تماس بگیرید:</p>

<ol>
 <li>پیام مستقیم در تویتر به اکانت pykello_fa</li>
 <li>ایمیل به hadi [at] moshayedi [dot] net.</li></ol>

<p>ممنون که وقت گذاشتید و امیدوارم استفاده کرده باشید.</p>
  <footer>
    <script type="text/javascript">
      !function(d,s,id){
          var js,fjs=d.getElementsByTagName(s)[0];
          if(!d.getElementById(id)){
              js=d.createElement(s);
              js.id=id;
              js.src="//platform.twitter.com/widgets.js";
              fjs.parentNode.insertBefore(js,fjs);
          }
      }(document,"script","twitter-wjs");
    </script>
    <a href="https://twitter.com/share"
       class="twitter-share-button"
       data-url="http://pykello.github.com/fa//fa/2021/04/%D9%BE%D8%B3%D8%AA%DA%AF%D8%B1%D8%B3-%DA%86%DA%AF%D9%88%D9%86%D9%87-%DA%A9%D8%A7%D8%B1-%D9%85%DB%8C-%DA%A9%D9%86%D8%AF-%D8%AC%D9%84%D8%B3%D9%87-%D8%AF%D9%88-%D8%AC%D8%AF%D9%88%D9%84-%D9%87%D8%A7%DB%8C-%D8%B3%DB%8C%D8%B3%D8%AA%D9%85%DB%8C.html"
       data-dnt="true">
      "Tweet"</a>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.identifier = undefined;
        this.page.url = undefined;
        this.page.title = undefined;
        this.page.category_id = undefined;
      };
      var disqus_shortname = 'pykello';
      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript';
          dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          dsq.setAttribute('data-timestamp', +new Date());
          (document.head || document.body).appendChild(dsq);
      })();
    </script>
    <noscript>
      Please enable JavaScript to view the
      <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>
  </footer>
</article>
        </main>
        <footer>
            <hr />
            <p><a href="https://twitter.com/pykello"
                  class="twitter-follow-button"
                  data-show-count="false"
                  data-lang="en">
                 "Follow Hadi Moshayedi"
               </a>
               <script type="text/javascript">
                 !function(d,s,id){
                     var js,fjs=d.getElementsByTagName(s)[0];
                     if(!d.getElementById(id)){
                         js=d.createElement(s);
                         js.id=id;
                         js.src="//platform.twitter.com/widgets.js";
                         fjs.parentNode.insertBefore(js,fjs);
                     }
                 }(document,"script","twitter-wjs");
               </script></p>
          </footer>
    </div>
  </body>
</html>